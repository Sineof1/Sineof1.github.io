<!DOCTYPE html>
<html lang = 'en'>
<head>
<meta charset = 'utf-8'>
<meta name="viewport" content="initial-scale=1, maximum-scale=1">
<meta name='description' content='Engagingly illustrated geometry proofs in narrative form.'>
<meta name = 'author' content = 'Joshua D. Fisher'>

<link rel='icon' href='https://lh4.googleusercontent.com/-KV4kSClOebQ/VSXiO563a4I/AAAAAAAAR_k/iAHD6fF42F0/s144-no/nbk_favicon.gif'>
<link href='//fonts.googleapis.com/css?family=Josefin+Sans' rel='stylesheet' type='text/css'>
<link href='//fonts.googleapis.com/css?family=Neucha' rel='stylesheet' type='text/css'>
<title>Pick's Theorem (HSG.CO.11)</title>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none"
});
</script>

<script type="text/javascript"
  src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

<style>
#nav {
   width: 100%;
   float: left;
   margin: 0 0 3em 0;
   padding: 0px;
   list-style: none;
}

#nav li {
   float: right;
   padding-right:20px;
}

#clear {
   width:60px;
   height:40px;
   margin-left:620px;
   margin-top:20px;
}

#nav li a {
   font-family: 'Josefin Sans', sans-serif;
   box-shadow: 1px 1px 1px #cccccc;
   border-radius:5px;
   font-variant:small-caps;
   display: block;
   padding: 8px 15px;
   text-decoration: none;
   font-weight: bold;
   color: #069;
}

#nav li a:hover {
   background-color: #f5f5f5;
}

button {
   outline: 0 none;
   box-shadow: 1px 1px 1px #cccccc;
   border:0px;
   background:#ffffff;
   font-size:1em;
   font-family: 'Josefin Sans', sans-serif;
   border-radius:5px;
   display:block;
   font-variant:small-caps;
   padding: 8px 15px;
   text-decoration: none;
   font-weight: bold;
   color: #069;
}

button:hover {
   background-color:#f5f5f5;
   cursor:pointer;
}

#blockquote {
   float:left;
   margin-top:0.5em;
   margin-right:10em;
   margin-bottom:1.4em;
   margin-left:5em;
   font-family:'Neucha';
   text-align:justify;
   font-size:1.6em;
   line-height:1.2em;
   box-shadow:1px 1px 1px 1px #f0f0f0;
   border-left:4px solid #CC9900;
   border-radius:5px;
   padding:10px 20px 10px 20px;
   -webkit-transition: all 0.5s linear;
   -o-transition: all 0.5s linear;
   -moz-transition: all 0.5s linear;
   transition: all 0.5s linear;
}

#blockquote:hover {
   background-color:#f8f8f8;
   padding:20px;
   box-shadow:2px 2px 2px 1px #888888;
   border-radius:10px;
}

mark {
   background-color:#ffffcc;
}

#Introduction p {
   font-family: 'Josefin Sans', sans-serif;
   margin-left:40px;
   text-align:justify;
   margin-right:100px;
   font-size:1.6em;
   line-height:1.6em;
   font-weight:600;
}

#Setup p {
   font-family: 'Josefin Sans', sans-serif;
   margin-left:40px;
   text-align:justify;
   margin-right:100px;
   font-size:1.6em;
   line-height:1.6em;
   font-weight:600;
}

#Finale p {
   font-family: 'Josefin Sans', sans-serif;
   margin-left:40px;
   text-align:justify;
   margin-right:100px;
   font-size:1.6em;
   line-height:1.6em;
   font-weight:600;
}

p::first-letter {
   font-size:120%;
}

h1, h2, hr {
   font-family: 'Josefin Sans', sans-serif;
   margin-left:40px;
}

h1 {
   font-weight:600;
   padding-bottom:10px;
}

hr {
   margin-bottom:40px;
    margin-right:100px;
}

#imgnorm {
   border:2px solid black;
   border-radius:5px;
   box-shadow: 5px 5px 5px  #888888;
   margin-left:40px;
   margin-right:100px;
   margin-top:20px;
   margin-bottom:25px;
   float:right;
}

#imgright {
   border-radius:5px;
   float:left; 
   margin-left:30px;
   margin-right:100px;
   margin-top:15px;
   margin-bottom:10px;
   transition: opacity 2s;
}

#imgright:hover {
   opacity:0.6;
}

#imgnorm:hover {
   box-shadow: 5px 5px 5px  #996699;
}

#canvas {
   cursor:pointer;
   padding:0px;
   margin-left:155px;
   margin-top:-90px;
}

#footnote1, #footnote2, #footnote3, #footnote4 {
   color:blue; 
   font-size:1.2em;
}

#footnote1:hover {
   cursor:pointer;
}

#footnote2:hover {
   cursor:pointer;
}

#footnote3:hover {
   cursor:pointer;
}

#footnote4:hover {
   cursor:pointer;
}

#citation {
   color:brown; 
   margin-left:5px; 
   font-family:Arial, sans;
   font-size:0.6em;
   font-weight:200;
}
</style>

</head>

<div id='nav'>
<li><a href='http://sineof1.github.io/math_notebook/home' target='_blank'>Home</a></li>
</div>

<body>
<h1>Pick's<br>Theorem</h1>
<article>
<section id="Introduction">
<canvas id='canvas' width='900px' height='500px'>Canvas not supported.</canvas>
<button id='clear' onclick='clearScreen()'>New</button>
<p>So, Pick's Theorem involves some interesting terminology, like <em>lattice polygon</em>, that you don't hear in your typical geometry class. And it 

can involve a neat methodology, mathematical induction, which isn't talked about enough, if at all, in high school--and which I won't talk about in 

this installment.</p>

<p>At the moment, you can click and drag on the dot grid above to draw stuff and see the boundary points of your polygons circled, and in the future, 

I'll hook this up with some more magic to highlight what Pick's theorem talks about. Play with it to see what makes it tick.</p>

<p>So, what does this theorem say? It says that when you draw any <a href='http://mathworld.wolfram.com/LatticePolygon.html' target='blank'>lattice 

polygon</a>, you can count the points on the interior, add that to half the number of points that lie on the sides (including the vertices), and 

subtract 1, and that will give you the area value of the polygon.</p>
<img id='imgnorm' src='https://lh3.googleusercontent.com/-8DsNowQ87NU/VSgVf2ejv2I/AAAAAAAASK0/OWgg_-uqiGg/w641-h293-no/trap_lattice.gif' width="400px" 

height="188px">
<p>As that definition at the link above will tell you, a lattice polygon is a polygon whose vertices are all on the points of a lattice, which is a 

"regularly spaced array of points." The figure at the right shows a trapezoid I drew on my homemade lattice above. Pick's Theorem says that the area of 

the trapezoid is equal to \(\small\mathtt{I_{p} + \frac{1}{2}B_{p} - 1}\). That is, the number of interior points, \(\small\mathtt{I_{p}}\), plus half 

the number of boundary points (including the vertices), \(\small\mathtt{B_{p}}\), minus 1 is equal to the area. </p>
<p>Compare the result of this formula to what you get when you find the area of the trapezoid using base and height measures: \(\small\mathtt{A = 

\frac{1}{2}h \cdot (b_{1} + b_{2})}\). And of course, draw your own to see. Think ridiculously simple, like a unit square, for example. Or ridiculously 

complex. Try to break the formula.</p>

</section>
<br>
<hr></hr>

<section id="Setup">
<h2>Always Start Simple</h2>

<p>As far as proving stuff, do what mathematicians do--instead of trying to tackle a really abstract and complex problem all at once, start with 

simpler instances of the general case and don't tell anyone until you've solved the harder problem. So, instead of "any lattice polygon," start with 

"any lattice rectangle."</p>
<a href="https://flic.kr/p/bUPrcN" target="blank"><img id='imgnorm' src='https://lh6.googleusercontent.com/-

tH5trjqFQcI/VSXiO_6lqmI/AAAAAAAASAI/nqu4BcDIkW8/w269-h180-no/lattice.jpg' width='400px' height='263px'></a>
<p>How many interior points are there in any lattice rectangle? Well, if you draw a rectangle on the lattice above, you will see that the interior 

points of a lattice rectangle form a smaller rectangle of their own. If the height of the original rectangle is \(\small\mathtt{h}\) units, then the 

smaller rectangle will have \(\small\mathtt{h - 1}\) points on its height. The same goes for the width, so the number of points on the interior of the 

rectangle will be \(\small\mathtt{(h - 1)(w - 1)}\). (You just have to get used to going back and forth between "units" and "points" in this 

explanation for it to make the most sense.)</p>
<img id='imgright' src='https://lh6.googleusercontent.com/-MW1-VO7V8iI/VSgVfutYMoI/AAAAAAAASKw/-ddnEN5SgTo/w424-h286-no/rec_lattice.gif' width='318px' 

height='215px'>
<p>What about boundary points? We can traverse the boundary of a rectangle, again relating the number of points we count to the width and height. So, 

going clockwise from the top of the rectangle at the left, first I count \(\small\mathtt{w + 1}\) points on the width (its width is 10 units, but there 

are 11 points). Then I count \(\small\mathtt{h}\) points along the right side (the height of the rectangle is 6 units, and this is the number I count, 

because I have already counted the top right vertex point). And so on. Adding up all the points and simplifying, we get \(\small\mathtt{2w + 2h}\) for 

the number of boundary points of a lattice rectangle.</p>

<p>Finally, Pick's theorem says that 
\[\mathtt{A = \frac{2w + 2h}{2} + (h - 1)(w - 1) - 1}\]
And this simplifies to \(\small\mathtt{hw}\), the area of the rectangle--and, more generally, any rectangle.</p>
</section>
<br>
<hr></hr>

<section id="Finale">
<p>Let's remember to talk more about this whole theorem at some point in the future. In the meantime, <a 

href='http://www.geometer.org/mathcircles/pick.pdf' target='blank'>here's a great paper on Pick's 
Theorem</a> with some nice explanations.

<h2>Postscript</h2>
<p>To my point above about mathematicians' silence on interim results and process, I came across <a href="http://www.vukutu.com/blog/2014/07/rigour-

and-speculation-in-pure-math/" target="blank">this wonderful quotation by mathematician Alexander Grothendieck</a>, who passed away in November of 

2014. Here he talks about 'speculation' in mathematics (in a <a href="http://permalink.gmane.org/gmane.science.mathematics.categories/3067" 

target="blank">1983 letter</a>):</p>
<div id='blockquote'>It is the kind of thing which has traditionally been lacking in mathematics since the very beginnings, I feel, which is one big 

drawback in comparison to all other sciences, as far as I know. Of course, no creative mathematician can afford not to "speculate," namely to do more 

or
less daring guesswork as an indispensable source of inspiration. The trouble is that, in obedience to a stern tradition, almost nothing of this appears 

in writing, and preciously little even in oral communication.</div>
</section>
</article>
<br>
<hr></hr>
</body>

<script>


var canvas = document.getElementById('canvas');
var context = canvas.getContext('2d');

var mouseIsDown = false;
var mouseMoves = false;
var begin, end;
var lines = [];
var boundary_points = [];
var slope_list = [];

function windowToCanvas(canvas, x, y) {
    var bbox = canvas.getBoundingClientRect();
    return {x: (x - bbox.left) * (canvas.width / bbox.width), y: (y - bbox.top) * (canvas.height / bbox.height)};
};

function clearScreen() {
    lines = [];
    boundary_points = [];
    slope_list = [];
    context.clearRect(0, 0, canvas.width, canvas.height);
    drawFigs();
    canvas.addEventListener('mousedown', startPoint);
    canvas.addEventListener('mousemove', drawLine);
    canvas.addEventListener('mouseup', finishLine);
    canvas.addEventListener('mousemove', highlight);
};

function drawFigs(col) {
    if (!col) col = '#8b3a3a';
    var points = [];
    context.fillStyle = '#888888';
    context.strokeStyle = '#888888';
    for (var x = 10; x <= canvas.width - 10; x += 20) {
        for (var y = 10; y <= canvas.height - 10; y += 20) {
            context.beginPath();
            context.arc(x, y, 2, 0, Math.PI * 2);
            context.stroke();
            context.fill();
            points.push({x: x, y: y});
        }
    }
    context.strokeStyle = col;
    context.lineWidth = 1;
    for (var i = 0; i < lines.length; i++) {
        context.beginPath();
        context.moveTo(lines[i][0].x, lines[i][0].y);
        context.lineTo(lines[i][1].x, lines[i][1].y);
        context.stroke();
    }
    context.fillStyle = 'white';
    context.fillRect(0, 5, 100, canvas.height - 5);
    context.fillRect(100, 5, canvas.width, 95);
    return points;
};

function match(point) {
   for (var p = 0; p < lattice_grid.length; p++) {
       if (point.x <= lattice_grid[p].x + 8 && point.x >= lattice_grid[p].x - 8
        && point.y <= lattice_grid[p].y + 8 && point.y >= lattice_grid[p].y - 8) {
           return p;
       }
   }
   return false;
};

function drawLine(evt) {
    evt.preventDefault();
    mouseMoves = true;
    if (mouseIsDown === false) return;
    mouseIsDown = true;
    var toLoc = windowToCanvas(canvas, evt.clientX, evt.clientY);
    context.clearRect(0, 0, canvas.width, canvas.height);
    lattice_grid = drawFigs();
    context.strokeStyle = '#8b3a3a';
    context.lineWidth = 1;
    context.beginPath();
    context.moveTo(lattice_grid[begin].x, lattice_grid[begin].y);
    context.lineTo(toLoc.x, toLoc.y);
    context.stroke();

    var p = match(toLoc);
    context.fillStyle = '#802a2a';
    context.strokeStyle = '#802a2a';
    context.beginPath();
    if (p) {
        context.arc(lattice_grid[p].x, lattice_grid[p].y, 4, 0, Math.PI * 2);
        context.fill();
        context.stroke();
        end = p;
    }
};

function highlight(evt) {
    mouseMoves = true;
    if (mouseIsDown === true) return;
    mouseIsDown = false;
    var loc = windowToCanvas(canvas, evt.clientX, evt.clientY);
    if (match(loc) && loc.x > 100 && loc.y > 100) {
        var p = match(loc);
        context.clearRect(lattice_grid[p].x - 5, lattice_grid[p].y - 5, 10, 10);
        context.fillStyle = '#802a2a';
        context.strokeStyle = '#802a2a';
        context.beginPath();
        context.arc(lattice_grid[p].x, lattice_grid[p].y, 4, 0, Math.PI * 2);
        context.fill();
        context.stroke();
    }
    else {
        context.clearRect(0, 0, canvas.width, canvas.height);
        drawFigs();
    }
};

function startPoint(evt) {
    evt.preventDefault();
    var loc = windowToCanvas(canvas, evt.clientX, evt.clientY);
    if (loc.x < 100 || loc.y < 100) return;
    mouseIsDown = true;
    if (match(loc)) {
        begin = match(loc);
    }
};

function finishLine(evt) {
    evt.preventDefault();
    mouseIsDown = false;
    context.clearRect(0, 0, canvas.width, canvas.height);
    drawFigs();
    context.strokeStyle = '#8b3a3a';
    context.lineWidth = 1;
    context.beginPath();
    if (lattice_grid[begin]) {
        context.moveTo(lattice_grid[begin].x, lattice_grid[begin].y);
        context.lineTo(lattice_grid[end].x, lattice_grid[end].y);
        context.stroke();
    
        lines.push([lattice_grid[begin], lattice_grid[end]]);
    }
    if (checkClosure()) {
        slope_list = [];
        runPick();
    }
};

function checkClosure() {
    if (lines.length > 2) {
    var testsx = [];
    var testsy = [];
    for (var i = 0; i < lines.length; i++) {
        testsx.push(lines[i][0].x);
        testsx.push(lines[i][1].x);
        testsy.push(lines[i][0].y);
        testsy.push(lines[i][1].y);
    }
    for (var w = 0; w < testsx.length; w++) {
        var countx = 0;
        var county = 0;
        for (var g = 0; g < testsx.length; g++) {
            if (testsx[w] === testsx[g]) countx += 1;
            if (testsy[w] === testsy[g]) county += 1;
        }
        if (countx % 2 !== 0 || county % 2 !== 0) return false;
    }
    return true;
    }
};

function runPick() {
    canvas.removeEventListener('mousemove', highlight);
    canvas.removeEventListener('mousedown', startPoint);
    for (var i = 0; i < lines.length; i++) {
        var slope = (lines[i][1].y - lines[i][0].y) / (lines[i][1].x - lines[i][0].x);
        if (slope === Infinity) slope = -Infinity;
        slope_list.push(slope);
        var xs = [];
        var ys = [];
        xs.push(lines[i][0].x, lines[i][1].x);
        ys.push(lines[i][0].y, lines [i][1].y);
        xs.sort();
        ys.sort();
        for (var b = 0; b < lattice_grid.length; b++) {
            if (slope === -Infinity || slope === Infinity) {
                var test1 = lattice_grid[b].y <= ys[1] && lattice_grid[b].y >= ys[0];
                if (lattice_grid[b].x === lines[i][0].x && test1) {
                    boundary_points.push(lattice_grid[b]);
                    context.beginPath();
                    context.strokeStyle = '#A2B5CD';
                    context.arc(lattice_grid[b].x, lattice_grid[b].y, 5, 0, Math.PI * 2);
                    context.stroke();
                }
            }
            else {
                var test2 = lattice_grid[b].x <= xs[1] && lattice_grid[b].x >= xs[0] && lattice_grid[b].y <= ys[1] && lattice_grid[b].y >= ys[0];
                if (lattice_grid[b].y - lines[i][0].y === slope * (lattice_grid[b].x - lines[i][0].x) && test2) {
                    boundary_points.push(lattice_grid[b]);
                    context.beginPath();
                    context.strokeStyle = '#A2B5CD';
                    context.arc(lattice_grid[b].x, lattice_grid[b].y, 5, 0, Math.PI * 2);
                    context.stroke();
        }}}}
        /*var both_pts = [];
        for (var rep = 0; rep < 2; rep++) {
            boundary_points.sort(function(k, l){return k.x - l.x;});
            var cop1_bndpts = [];
            for (var cop1 = 0; cop1 < boundary_points.length; cop1++) cop1_bndpts.push(boundary_points[cop1]);
            boundary_points.sort(function(ss, tt){return ss.y - tt.y;});
            var cop2_bndpts = [];
            for (var cop2 = 0; cop2 < boundary_points.length; cop2++) cop2_bndpts.push(boundary_points[cop2]);
            slope_list.sort();
            console.log(slope_list);
            for (var r = 0; r < lattice_grid.length; r++) {
                if ((lattice_grid[r].y - cop1_bndpts[rep * (cop1_bndpts.length - 1)].y) / (lattice_grid[r].x - cop1_bndpts[rep * (cop1_bndpts.length - 

1)].x) < slope_list[slope_list.length - 1]
                    && (lattice_grid[r].y - cop1_bndpts[rep * (cop1_bndpts.length - 1)].y) / (lattice_grid[r].x - cop1_bndpts[rep * (cop1_bndpts.length 

- 1)].x) > slope_list[0]
                    && lattice_grid[r].x > cop1_bndpts[0].x && lattice_grid[r].x < cop1_bndpts[cop1_bndpts.length - 1].x
                    && lattice_grid[r].y > cop2_bndpts[0].y && lattice_grid[r].y < cop2_bndpts[cop2_bndpts.length - 1].y) {
                    both_pts.push(r);
                }
            }
        }
        var final_pts = [];
        for (var chk1 = 0; chk1 < both_pts.length; chk1++) {
            var count_again = 0;
            for (var chk2 = 0; chk2 < both_pts.length; chk2++) {
                if (both_pts[chk1] === both_pts[chk2]) count_again++;
            }
            if (count_again === 2) final_pts.push(both_pts[chk1]);
        }
        for (var meh = 0; meh < final_pts.length; meh++) {
            context.beginPath();
            context.strokeStyle = '#ff0000';
            context.arc(lattice_grid[final_pts[meh]].x, lattice_grid[final_pts[meh]].y, 5, 0, Math.PI * 2);
            context.stroke();
        }*/
};

var lattice_grid = drawFigs();
canvas.addEventListener('mousedown', startPoint);
canvas.addEventListener('mousemove', drawLine);
canvas.addEventListener('mousemove', highlight);
canvas.addEventListener('mouseup', finishLine);
</script>
</footer>
</html>
