<!DOCTYPE html>
<html lang = 'en'>
<head>
<meta name="viewport" content="initial-scale=1, maximum-scale=1">
<meta charset = 'utf-8'>
<meta name='description' content='Engagingly illustrated geometry proofs in narrative form.'>
<meta name = 'author' content = 'Joshua D. Fisher'>

<link rel='icon' href='https://lh4.googleusercontent.com/-KV4kSClOebQ/VSXiO563a4I/AAAAAAAAR_k/iAHD6fF42F0/s144-no/nbk_favicon.gif'>
<link href='//fonts.googleapis.com/css?family=Josefin+Sans' rel='stylesheet' type='text/css'>
<link href='//fonts.googleapis.com/css?family=Neucha' rel='stylesheet' type='text/css'>
<title>The Cissoid</title>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none"
});
</script>

<script type="text/javascript"
  src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

<style>
#nav {
   width: 100%;
   float: left;
   margin: 0 0 3em 0;
   padding: 0px;
   list-style: none;
}

#nav li {
   float: right;
   padding-right:20px;
}

#clear {
   width:60px;
   height:40px;
   margin-bottom:15px;
}

#desmos {
   margin-left:40px;
   border:0px solid #ffffff; 
   border-radius:5px;
   box-shadow: 5px 5px 5px  #888888;"
}

#nav li a {
   font-family: 'Josefin Sans', sans-serif;
   box-shadow: 1px 1px 1px #cccccc;
   border-radius:5px;
   font-variant:small-caps;
   display: block;
   padding: 8px 15px;
   text-decoration: none;
   font-weight: bold;
   color: #069;
}

#nav li a:hover {
   background-color: #f5f5f5;
}

button {
   outline: 0 none;
   box-shadow: 1px 1px 1px #cccccc;
   border:0px;
   background:#ffffff;
   font-size:1em;
   font-family: 'Josefin Sans', sans-serif;
   border-radius:5px;
   display:block;
   font-variant:small-caps;
   padding: 8px 15px;
   text-decoration: none;
   font-weight: bold;
   color: #069;
}

button:hover {
   background-color:#f5f5f5;
   cursor:pointer;
}

#blockquote {
   float:left;
   margin-top:0.5em;
   margin-right:10em;
   margin-bottom:1.4em;
   margin-left:5em;
   font-family:'Neucha';
   text-align:justify;
   font-size:1.6em;
   line-height:1.2em;
   box-shadow:1px 1px 1px 1px #f0f0f0;
   border-left:4px solid #CC9900;
   border-radius:5px;
   padding:10px 20px 10px 20px;
   -webkit-transition: all 0.5s linear;
   -o-transition: all 0.5s linear;
   -moz-transition: all 0.5s linear;
   transition: all 0.5s linear;
}

#blockquote:hover {
   background-color:#f8f8f8;
   padding:20px;
   box-shadow:2px 2px 2px 1px #888888;
   border-radius:10px;
}

mark {
   background-color:#ffffcc;
}

#Introduction p {
   font-family: 'Josefin Sans', sans-serif;
   margin-left:40px;
   text-align:justify;
   margin-right:100px;
   font-size:1.6em;
   line-height:1.6em;
   font-weight:600;
}

#Setup p {
   font-family: 'Josefin Sans', sans-serif;
   margin-left:40px;
   text-align:justify;
   margin-right:100px;
   font-size:1.6em;
   line-height:1.6em;
   font-weight:600;
}

#Finale p {
   font-family: 'Josefin Sans', sans-serif;
   margin-left:40px;
   text-align:justify;
   margin-right:100px;
   font-size:1.6em;
   line-height:1.6em;
   font-weight:600;
}

p::first-letter {
   font-size:120%;
}

h1, h2, hr {
   font-family: 'Josefin Sans', sans-serif;
   margin-left:40px;
}

h1 {
   font-weight:600;
   padding-bottom:10px;
}

hr {
   margin-bottom:40px;
    margin-right:100px;
}

#imgnorm {
   border:2px solid black;
   border-radius:5px;
   box-shadow: 5px 5px 5px  #888888;
   margin-left:40px;
   margin-right:100px;
   margin-top:20px;
   margin-bottom:25px;
   float:right;
}

#imgright {
   border-radius:5px;
   float:left; 
   margin-left:30px;
   margin-right:100px;
   margin-top:15px;
   margin-bottom:10px;
   transition: opacity 2s;
}

#imgright:hover {
   opacity:0.6;
}

#imgnorm:hover {
   box-shadow: 5px 5px 5px  #996699;
}

#canvas {
   width:400px;
   height:400px;
   float:right;
   margin-right:74px;
   margin-left:30px;
}

#canvas:hover {
   cursor:pointer;
}

#footnote1, #footnote2, #footnote3, #footnote4 {
   color:blue; 
   font-size:1.2em;
}

#footnote1:hover {
   cursor:pointer;
}

#footnote2:hover {
   cursor:pointer;
}

#footnote3:hover {
   cursor:pointer;
}

#footnote4:hover {
   cursor:pointer;
}

#citation {
   color:brown; 
   margin-left:5px; 
   font-family:Arial, sans;
   font-size:0.6em;
   font-weight:200;
}
</style>
</head>

<div id='nav'>
<li><a href='http://sineof1.github.io/math_notebook/home' target='_blank'>Home</a></li>
</div>

<body>
<div style='position:absolute; top:-115px; left:-190px;'><img src='https://lh4.googleusercontent.com/-UwfsqxVvOYs/VScL6V9YnmI/AAAAAAAASFs/V1rVrYikZPw/w978-h455-

no/ivy.gif'></div>
<h1>Ivy-League Math</h1>

<article>
<section id="Introduction">
<img id='imgnorm' src='https://lh6.googleusercontent.com/-XvAHClY_7yw/VScL6FcEVcI/AAAAAAAASFo/P5L7iin2aCw/w509-h510-no/cissoid_pic.gif'>
<p>The name of this special little curve--the diamond-shaped one that is partly in dashed lines at the right--is the <a href="http://mathworld.wolfram.com/CissoidofDiocles.html" 

target='blank'>cissoid</a> and is pronounced SISS-oid. Specifically, this cissoid at the right is sometimes called the Cissoid of Diocles. The Greek word that is the ancestor to "cissoid" 

apparently means "ivy-shaped," and it is a little disappointing to me that I couldn't find a connection to "kiss," seeing as the cissoid (in all quadrants of the circle) resembles the shape of 

the mouth opening when <a href="http://thumb9.shutterstock.com/display_pic_with_logo/468649/468649,1293936551,2/stock-vector-vector-illustration-or-red-ans-pink-kissing-lips-

68093479.jpg" target="blank">cartoonish lips are puckered cartoonishly</a>.</p>
<p>The following appears in Heath's translation of the <em>Elements</em> as a method for generating the cissoid:</p>
<div id='blockquote'>Let \(\overline{\small\mathtt{AC}}\), \(\overline{\small\mathtt{BD}}\) be diameters at right angles in a circle with centre \(\small\mathtt{O}\). Let \(\small\mathtt

{E}\), \(\small\mathtt{F}\) be points on the quadrants \(\small\mathtt{BC}\), \(\small\mathtt{BA}\) respectively such that the arcs \(\small\mathtt{BE}\), \(\small\mathtt{BF}\) are 

equal.<br><br>
Draw \(\overline{\small\mathtt{EG}}\), \(\overline{\small\mathtt{FH}}\) perpendicular to \(\overline{\small\mathtt{CA}}\). Join \(\small\mathtt{AE}\) and let \(\small\mathtt{P}\) be its 

intersection with \(\overline{\small\mathtt{FH}}\).<br><br>
The cissoid is the locus of all the points \(\small\mathtt{P}\) corresponding to different positions of \(\small\mathtt{E}\) on the quadrant \(\small\mathtt{BC}\) and of \(\small\mathtt{F}\) 

at an equal distance from \(\small\mathtt{B}\) along the arc \(\small\mathtt{BA}\).</div>

</section>
<br>
<hr></hr>

<section id="Setup">
<h2>Let's Do It Ourselves</h2>
<canvas id='canvas' width='400px' height='400px'>Canvas not supported.</canvas>
<p>Play with the diagram at the right to see how the construction above works. Drag the blue point (this is point \(\small\mathtt{E}\) in the diagram above) in Quadrant III to move 

the orange intersection point (\(\small\mathtt{P}\) above) to generate the cissoid. In this version, I've also included the various reflections of point \(\small\mathtt{P}\) in the different 

quadrants. Press Reset to clear the circle.</p>
<center>
<button id='clear' onclick='init()' style='display:inline;'>Reset</button>
</center>
<p>I don't know about you, but I certainly see puckering. I'm also reminded of theater curtains when I look at the curves in Quadrants I and II. Is there anything "cissoidal" about the 

contraptions they use to open these curtains? Or maybe there's something similar in the way our kissing muscles do their jobs.</p>
</section>
<br>
<hr></hr>
<section id="Finale">
<h2>The Equation Is In the Code</h2>
<p>For the little cissoid-making machine above, here is the code that assigns the \(\small\mathtt{y}\)-value of point \(\small\mathtt{P}\):</p>
<center><img src='https://lh3.googleusercontent.com/-5jEGEd0oK-E/VScL6bT_LoI/AAAAAAAASFw/w-s0JzVZD7I/w1200-h39-no/p_code.gif'></center>
<p>Hopefully it's straightforward to see that this is a point-slope equation just moved around a little. I use H.x, the \(\small\mathtt{x}\)-value of point \(\small\mathtt{H}\), instead of the 

one for point \(\small\mathtt{P}\) because they are the same. The cool thing is that when we translate this into Cartesian coordinates using the coordinates of the circle as a reference 

(and shifting the circle to center at the origin), we get this loveliness:
\[\small\mathtt{y = (\frac{\sqrt{r^2 - x^2}}{x - r} \cdot -2x) + \sqrt{r^2 - x^2}}\]</p>
<p>This is not quite the equation for the cissoid we're looking at, but it is one piece. We can put all the pieces together like in the <a 

href="https://www.desmos.com/calculator/ylupxnnhf8" target="blank">Desmos graph</a> below. Our equation above is the first equation listed for the graph. You should see that the 

curves inside the circle don't tell the whole story:</p>
<iframe id='desmos' src='https://www.desmos.com/calculator/liwcmnrjpg' width='88%' height='380px'></iframe>
</section>
<br>
<hr></hr>
</article>
</body>
<script>

var canvas = document.getElementById('canvas');
var context = canvas.getContext('2d');

function windowToCanvas_touch(elem, x, y) {
    var box = elem.getBoundingClientRect();
    var body = document.body;
    var docElem = document.documentElement;
    var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
    var clientTop = docElem.clientTop || body.clientTop || 0;
    var clientLeft = docElem.clientLeft || body.clientLeft || 0;
    var top  = box.top +  scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;
    return { y: (y - top) * (canvas.height / box.height), x: (x - left) * (canvas.width / box.width) };
};

function windowToCanvas_mouse(canvas, x, y) {
    var bbox = canvas.getBoundingClientRect();
    return {x: (x - bbox.left) * (canvas.width / bbox.width), y: (y - bbox.top) * (canvas.height / bbox.height)};
};

var r = 175;
var mouseIsDown = false;
var t_points = [];

var circle = {x: 200, y: 200, radius: r,
              draw: function() {context.beginPath();
                                context.strokeStyle = 'black';
                                context.lineWidth = 1;
                                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                                context.stroke();
                                context.moveTo(25, 200);
                                context.lineTo(375, 200);
                                context.stroke();
                                context.moveTo(200, 25);
                                context.lineTo(200, 375);
                                context.stroke();}};
var point = {radius: 3, ltr: '', color: 'black',
             draw: function() {context.beginPath();
                               context.strokeStyle = this.color;
                               context.fillStyle = this.color;
                               context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                               context.stroke();
                               context.fill();}};

var point_A = Object.create(point, {x: {value: 375}, y: {value: 200}, ltr: {value: 'A'}});
var point_B = Object.create(point, {x: {value: 200}, y: {value: 375}, ltr: {value: 'B'}});
var point_C = Object.create(point, {x: {value: 25}, y: {value: 200}, ltr: {value: 'C'}});
var point_D = Object.create(point, {x: {value: 200}, y: {value: 25}, ltr: {value: 'D'}});
var point_O = Object.create(point, {x: {value: 200}, y: {value: 200}, ltr: {value: 'O'}});

var point_E = Object.create(point, {ltr: {value: 'E'}, color: {value: 'blue'}});
var point_F = Object.create(point, {ltr: {value: 'F'}});
var point_G = Object.create(point, {y: {value: 200}, ltr: {value: 'G'}});
var point_H = Object.create(point, {y: {value: 200}, ltr: {value: 'H'}});

var point_P = Object.create(point, {ltr: {value: 'P'}, color: {value: '#cc8400'}});

var points = [point_E, point_F, point_G, point_H, point_P, point_A, point_B, point_C, point_D, point_O];

function init() {
    context.clearRect(0, 0, canvas.width, canvas.height);
    t_points = [];
    circle.draw();
    context.beginPath();
    context.strokeStyle = 'black';
    point_E.x = 125;
    point_E.y = Math.sqrt(25000) + 200;
    point_F.x = 275;
    point_F.y = Math.sqrt(25000) + 200;
    point_G.x = 125;
    point_G.y = 200;
    point_H.x = 275;
    point_H.y = 200;
    point_P.x = 275;
    point_P.y = ((point_E.y - point_A.y) / (point_E.x - point_A.x)) * (point_H.x - point_E.x) + point_E.y;
    context.moveTo(point_E.x, point_E.y);
    context.lineTo(point_G.x, point_G.y);
    context.stroke();
    context.beginPath();
    context.moveTo(point_F.x, point_F.y);
    context.lineTo(point_H.x, point_H.y);
    context.stroke();
    context.moveTo(point_A.x, point_A.y);
    context.lineTo(point_E.x, point_E.y);
    context.stroke();
    for (var ind in points) points[ind].draw();
};

function redraw() {
    context.clearRect(0, 0, canvas.width, canvas.height);
    circle.draw();
    context.beginPath();
    context.strokeStyle = 'black';
    context.moveTo(point_E.x, point_E.y);
    context.lineTo(point_G.x, point_G.y);
    context.stroke();
    context.beginPath();
    context.moveTo(point_F.x, point_F.y);
    context.lineTo(point_H.x, point_H.y);
    context.stroke();
    context.moveTo(point_A.x, point_A.y);
    context.lineTo(point_E.x, point_E.y);
    context.stroke();
    for (var ind in points) points[ind].draw();
    for (var inx in t_points) {
        if (inx % 5 === 0) t_points[inx].draw();
    }
};

function movePoint() {
    if (mouseIsDown === false) return;
    var loc = windowToCanvas_mouse(canvas, event.clientX, event.clientY);
    if (loc.x >= 24 && loc.x <= 200) {
        point_E.x = loc.x;
        point_E.y = Math.sqrt(30625 - Math.pow((point_E.x - 200), 2)) + 200;
        point_F.x = 200 + (200 - point_E.x);
        point_F.y = point_E.y;
        point_G.x = point_E.x;
        point_G.y = 200;
        point_H.x = point_F.x;
        point_H.y = 200;
        point_P.x = point_H.x;
        point_P.y = ((point_E.y - point_A.y) / (point_E.x - point_A.x)) * (point_H.x - point_E.x) + point_E.y;
        var t_point = {x: point_P.x, y: point_P.y, radius: 1, color: point_P.color, draw: point_P.draw};
        var t_point3 = {x: 200 - (point_P.x - 200), y: point_P.y, radius: 1, color: point_P.color, draw: point_P.draw};
        var t_point2 = {x: t_point3.x, y: 200 - (t_point3.y - 200), radius: 1, color: point_P.color, draw: point_P.draw};
        var t_point1 = {x: t_point.x, y: 200 - (t_point.y - 200), radius: 1, color: point_P.color, draw: point_P.draw};
        t_points.push(t_point, t_point3, t_point2, t_point1);
    }
    redraw();
};

init();

canvas.addEventListener('mousedown', function() {mouseIsDown = true;}, false);
canvas.addEventListener('mousemove', movePoint, false);
canvas.addEventListener('mouseup', function() {mouseIsDown = false;}, false);
</script>
</html>
